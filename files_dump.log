.env:
# strong random pass, 24+ chars
REDIS_PASS=YHxk2kbnUq1fFcfLk8aEVe0y
docker-compose.yaml:
version: "3.9"

###############################################################################
# FlashProxy – Auth Stack (runs on its own VM, separate from the HAProxy edge)
###############################################################################
# • Redis 7.2 – durable AOF, password-protected
# • Auth-SPOA – tiny Go service that validates proxy creds via Redis
#
# Both containers use `network_mode: host` so they bind directly to the VM’s
# ports (6379 and 9000).  HAProxy nodes just point at vm_ip:9000.
#
# Secrets: keep REDIS_PASS in a local          .env    file   or
#          store it as a Docker secret (shown below).
###############################################################################

services:
  # ────────── Redis (credentials DB) ──────────
  redis:
    image: redis:7.2-alpine                # latest alpine tag
    container_name: redis
    restart: unless-stopped
    network_mode: host                     # ← binds :6379 on the VM
    command: >
      redis-server
        --appendonly yes                   # durable AOF
        --requirepass "$${REDIS_PASS}"     # password from env/secret
    volumes:
      - redis_data:/data
    env_file: [.env]                       # holds REDIS_PASS=…

    healthcheck:
      test: ["CMD-SHELL",
             "redis-cli -a $$REDIS_PASS ping | grep PONG || exit 1"]
      interval: 10s
      retries: 5
      timeout: 3s

  # ────────── SPOE auth-agent ──────────
  auth-spoa:
    build:
      context: ./flash-auth-agent          # folder that has Dockerfile / main.go
      dockerfile: Dockerfile
    container_name: auth-spoa
    restart: unless-stopped
    network_mode: host                     # ← binds :9000 on the VM
    depends_on: [redis]
    env_file: [.env]
    command: >
      -listen=:9000
      -redis=127.0.0.1:6379
      -redis-password=$${REDIS_PASS}

volumes:
  redis_data:

# ───── optional: keep secrets out of .env ─────
# secrets:
#   redis_pass:
#     file: ./redis.pass

Dockerfile:
# ───── build stage ─────
FROM golang:1.22-alpine AS build
WORKDIR /src
COPY go.mod go.sum ./
RUN go mod download

COPY . .
RUN CGO_ENABLED=0 go build -o /spoa .

# ───── runtime stage ─────
FROM alpine:3.20
RUN addgroup -S spoa && adduser -S spoa -G spoa
USER spoa

COPY --from=build /spoa /spoa
EXPOSE 9000/tcp
ENTRYPOINT ["/spoa"]
# default flags can be overridden from docker-compose
CMD ["-listen=:9000","-redis=redis:6379"]

go.mod:
module github.com/thealonlevi/fp-prod/flashproxy-infra/flash-auth-agent

go 1.22

require (
	github.com/negasus/haproxy-spoe-go v1.0.6 // <─ root module at v1.0.6
	github.com/redis/go-redis/v9 v9.5.0
	golang.org/x/crypto v0.18.0
)

require (
	github.com/cespare/xxhash/v2 v2.2.0 // indirect
	github.com/dgryski/go-rendezvous v0.0.0-20200823014737-9f7001d12a5f // indirect
)

go.sum:
github.com/bsm/ginkgo/v2 v2.12.0 h1:Ny8MWAHyOepLGlLKYmXG4IEkioBysk6GpaRTLC8zwWs=
github.com/bsm/ginkgo/v2 v2.12.0/go.mod h1:SwYbGRRDovPVboqFv0tPTcG1sN61LM1Z4ARdbAV9g4c=
github.com/bsm/gomega v1.27.10 h1:yeMWxP2pV2fG3FgAODIY8EiRE3dy0aeFYt4l7wh6yKA=
github.com/bsm/gomega v1.27.10/go.mod h1:JyEr/xRbxbtgWNi8tIEVPUYZ5Dzef52k01W3YH0H+O0=
github.com/cespare/xxhash/v2 v2.2.0 h1:DC2CZ1Ep5Y4k3ZQ899DldepgrayRUGE6BBZ/cd9Cj44=
github.com/cespare/xxhash/v2 v2.2.0/go.mod h1:VGX0DQ3Q6kWi7AoAeZDth3/j3BFtOZR5XLFGgcrjCOs=
github.com/dgryski/go-rendezvous v0.0.0-20200823014737-9f7001d12a5f h1:lO4WD4F/rVNCu3HqELle0jiPLLBs70cWOduZpkS1E78=
github.com/dgryski/go-rendezvous v0.0.0-20200823014737-9f7001d12a5f/go.mod h1:cuUVRXasLTGF7a8hSLbxyZXjz+1KgoB3wDUb6vlszIc=
github.com/negasus/haproxy-spoe-go v1.0.6 h1:uJ5coC6n0p4tI0MbVPna4ztFTpW1P3pzswvjuKAF8X4=
github.com/negasus/haproxy-spoe-go v1.0.6/go.mod h1:ZrBizxtx2EeLN37Jkg9w9g32a1AFCJizA8vg46PaAp4=
github.com/redis/go-redis/v9 v9.5.0 h1:Xe9TKMmZv939gwTBcvc0n1tzK5l2re0pKw/W/tN3amw=
github.com/redis/go-redis/v9 v9.5.0/go.mod h1:hdY0cQFCN4fnSYT6TkisLufl/4W5UIXyv0b/CLO2V2M=
golang.org/x/crypto v0.18.0 h1:PGVlW0xEltQnzFZ55hkuX5+KLyrMYhHld1YHO4AKcdc=
golang.org/x/crypto v0.18.0/go.mod h1:R0j02AL6hcrfOiy9T4ZYp/rcWeMxM3L6QYxlOuEG1mg=

main.go:
package main

import (
	"context"
	"flag"
	"log"
	"net"
	"time"

	"github.com/negasus/haproxy-spoe-go/action"
	"github.com/negasus/haproxy-spoe-go/agent"
	"github.com/negasus/haproxy-spoe-go/logger"
	"github.com/negasus/haproxy-spoe-go/request"
	"github.com/redis/go-redis/v9"
	"golang.org/x/crypto/bcrypt"
)

/* ───── CLI flags ───────────────────────────────────────────────────────── */

var (
	listenAddr   = flag.String("listen", ":9000", "SPOE listen address")
	redisAddr    = flag.String("redis", "127.0.0.1:6379", "Redis host:port")
	redisPass    = flag.String("redis-password", "", "Redis AUTH password")
	redisDB      = flag.Int("redis-db", 0, "Redis DB number")
	timeoutRedis = flag.Duration("redis-timeout", 500*time.Millisecond, "Redis dial/read timeout")
)

var (
	ctx = context.Background()
	rdb *redis.Client
)

/* ───── SPOE message handler ───────────────────────────────────────────── */

func authHandler(req *request.Request) {
	msg, err := req.Messages.GetByName("check_credentials")
	if err != nil {
		req.Actions.SetVar(action.ScopeTransaction, "auth_ok", 0)
		return
	}

	usr, ok1 := msg.KV.Get("username")
	pwd, ok2 := msg.KV.Get("password")
	if !ok1 || !ok2 {
		req.Actions.SetVar(action.ScopeTransaction, "auth_ok", 0)
		return
	}

	username := usr.(string)
	password := pwd.(string)

	hash, err := rdb.HGet(ctx, "user:"+username, "pwd").Result()
	if err != nil {
		req.Actions.SetVar(action.ScopeTransaction, "auth_ok", 0)
		return
	}

	if bcrypt.CompareHashAndPassword([]byte(hash), []byte(password)) == nil {
		req.Actions.SetVar(action.ScopeTransaction, "auth_ok", 1)
	} else {
		req.Actions.SetVar(action.ScopeTransaction, "auth_ok", 0)
	}
}

/* ───── main ───────────────────────────────────────────────────────────── */

func main() {
	flag.Parse()

	/* Redis connection */
	rdb = redis.NewClient(&redis.Options{
		Addr:        *redisAddr,
		Password:    *redisPass,
		DB:          *redisDB,
		DialTimeout: *timeoutRedis,
		ReadTimeout: *timeoutRedis,
	})
	if err := rdb.Ping(ctx).Err(); err != nil {
		log.Fatalf("Redis ping failed: %v", err)
	}

	/* TCP listener */
	listener, err := net.Listen("tcp", *listenAddr)
	if err != nil {
		log.Fatalf("listen error: %v", err)
	}

	/* SPOE agent */
	spoeAgent := agent.New(authHandler, logger.NewDefaultLog())
	log.Printf("spoe-auth-agent listening on %s", *listenAddr)

	if err := spoeAgent.Serve(listener); err != nil {
		log.Fatalf("agent serve error: %v", err)
	}
}

